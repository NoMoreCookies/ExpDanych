---
title: "Sprawozdanie 2"
author: "Kacper Szmigielski, 282255 i Mateusz Wizner"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
    toc_depth: '3'
    df_print: paged
  pdf_document:
    toc: true
    fig_caption: true
    fig_width: 5
    fig_height: 4
    toc_depth: 3
    number_sections: true
header-includes:
- \usepackage[OT4]{polski}
- \usepackage[utf8]{inputenc}
- \usepackage{graphicx}
- \usepackage{float}
- \usepackage{xcolor}
subtitle: Eksploracja danych
fontsize: 12pt
---

```{r setup, include=FALSE}
#USTAWIENIA DO PROJEKTU 
### echo = FALSE (Nie wypisuje kodu przy egzekucji programu)
### message = FALSE (Nie wyświetla jakiś powiadomień)
### warning = Flase (Nie wyświetla błędów jak się pojawią)
#---------------------------------------------------------

knitr::opts_chunk$set(echo = FALSE )
knitr::opts_chunk$set(message = FALSE, waring = FALSE )
knitr::opts_chunk$set(gif.pos = "H", out.extra = "", fig.align = "center")

#---------------------------------------------------------
```

```{r DATA_IMPORT}
#IMPORT DANYCH
#---------------------------------------------------------

data <- read.csv("uaScoresDataFrame.csv") 
head(data)


#---------------------------------------------------------
```

```{r Import_bibliotek}
#POTRZEBNE BIBLIOTEKI
#---------------------------------------------------------
library(knitr)
library(dplyr)
library(kableExtra)
library(patchwork)
library(ggplot2)
library(arules)
library(e1071)
#---------------------------------------------------------
```
# ZADANIE 1 (Dyskretyzacja(przedziałowanie) cech ciągłych)
##  a) Dane: iris (R-pakiet datasets).

**3** Pierwsze wiersze z pakietu iris
```{r Dane_iris_przykład}
#DANE
#---------------------------------------------------------
data <- iris
#---------------------------------------------------------
kable(head(data,3))
```
Zbiór danych zawiera wyniki pomiarów uzyskanych dla **trzech gatunków irysów** (tj. setosa, versicolor i virginica) i został **udostępniony przez Ronalda Fishera w roku 1936.**

– **Pomiary** dotyczą **długości oraz szerokości** dwóch różnych części kwiatu– działki **kielicha (ang. sepal) oraz płatka (ang. petal).**

##  b) Wybór cech

Cechy, inaczej właściwie możemy to rozstrzygać jako kolumny, które charakteryzują się **największym zróżnicowaniem** w stosunku do rodzaju gatunku


```{r zad1b}
#TWORZENIE WYKRESÓW 1
#---------------------------------------------------------
p1 <- ggplot(data,aes(x = Sepal.Length,col = Species))+
  geom_histogram()
p2 <- ggplot(data,aes(x = Sepal.Width,col = Species))+
  geom_histogram()
p3 <- ggplot(data,aes(x = Petal.Length,col = Species))+
  geom_histogram()
p4 <- ggplot(data,aes(x = Petal.Width,col = Species))+
  geom_histogram()
#---------------------------------------------------------

#RYSOWANIE WYKRESÓW
#---------------------------------------------------------
(p1 + p2) / (p3 + p4) +
  plot_layout(guides = "collect") &
  theme(legend.position = "bottom",)
#---------------------------------------------------------

```

Po przeanalizowaniu histogramów, widać ,że warto zwrócić uwagę na takie cechy jak **Petal.Length i Petal.Width**, ponieważ

widać dobrze zaznaczone przedziały w których występuje większość kwiatków danego gatunku.

Dalej warto jest też spojrzeć na to jak nasze *obserwawcje* teoretycznie rozkładają się w przestrzeni 2D, aby to zrobić
dodajemy jedną dodatkową kolumnę y, wypełnioną losowymi liczbami od 0 do 1 (rozkłąd jednostajny)

```{r zad1b1}
#DODATKOWY WIERSZ DO WIZUALIZACJI
#-----/----------------------------------------------------
data$y <- runif(nrow(data))
#---------------------------------------------------------

#TWORZENIE WYKRESÓW
#---------------------------------------------------------
p1 <- ggplot(data,aes(x = Sepal.Length,y=y,col = Species))+
  geom_point()
p2 <- ggplot(data,aes(x = Sepal.Width,y=y ,col = Species))+
  geom_point()
p3 <- ggplot(data,aes(x = Petal.Length,y=y ,col= Species))+
  geom_point()
p4 <- ggplot(data,aes(x = Petal.Width,y=y ,col=Species))+
  geom_point()
#---------------------------------------------------------


#RYSOWANIE WYKRESÓW
#---------------------------------------------------------
(p1 + p2) / (p3 + p4) +
  plot_layout(guides = "collect") &
  theme(legend.position = "bottom",)
#---------------------------------------------------------

```

Wykresy typu scatter-plot potwierdzają ,że **Petal.Length i Petal.Width** są bardzo dobry wyborem cech, które mogłyby być wyznacznikami gatunków roślin.

Musimy jednak wybrać wartości najlepsze i najgorsze, aby to zrobić przeanalizujemy jeszcze boxploty.

```{r zad1b2}

#TWORZENIE WYKRESÓW
#---------------------------------------------------------
p1 <- ggplot(data,aes(x = Sepal.Length,y=Species,col = Species))+
  geom_boxplot()
p2 <- ggplot(data,aes(x = Sepal.Width,y=Species ,col = Species))+
  geom_boxplot()
p3 <- ggplot(data,aes(x = Petal.Length,y=Species ,col= Species))+
  geom_boxplot()
p4 <- ggplot(data,aes(x = Petal.Width,y=Species ,col=Species))+
  geom_boxplot()
#---------------------------------------------------------

#RYSOWANIE WYKRESÓW
#---------------------------------------------------------
(p1 + p2) / (p3 + p4) +
  plot_layout(guides = "collect") &
  theme(legend.position = "bottom",)
#---------------------------------------------------------

```
Na ich podstawaie możemy uznać, że Petal.Width może stanowić najlepszy wyznacznik gatunku roślin
Najgorszym natomiast jest Sepal.Width, tutaj duża część gatunków dzieli te same wartości tej cechy.

##  c) Porównanie nienadzorowanych metod dyskretyzacji

```{r Przygotowanie_danych}
#PRZYGOTOWANIE DANUYCH TRENINGOWYCH
#---------------------------------------------------------
trainingData1 <- data$Petal.Width
trainingData2 <- data$Sepal.Length
#---------------------------------------------------------
```

```{r drawing_hist_method}

#DEFINIOWANIE METODY
#---------------------------------------------------------
hist_plot <- function(trainingData,method){
  
  results <- discretize(trainingData, breaks = 3, method = method)
  breaks.equal.frq <- attributes(results)$"discretized:breaks"
  
  return (ggplot(data,aes(x = trainingData1,col = Species,main="Metoda: equal frequency discretization"))+
  geom_histogram()+
    geom_vline(xintercept = breaks.equal.frq, col = "red", lwd=0.5))
}
#---------------------------------------------------------

```

```{r drawing scatter_metohod}
#DEFINIOWANIE METODY
#---------------------------------------------------------
scatter_plot <- function(trainingData,method){
  
  results <- discretize(trainingData, breaks = 3, method = method)
  breaks.equal.frq<- attributes(results)$"discretized:breaks"
  
  return (ggplot(data,aes(x = trainingData,y=y ,col=Species))+
  geom_point()+
geom_vline(xintercept = breaks.equal.frq, col = "red", lwd=0.5))
}
#---------------------------------------------------------

```

### Równe częstości

#### Dla najlepszej
```{r frequences_najl}

#FREQUENCE_METHOD
#---------------------------------------------------------
hist_plot(trainingData1,"Frequency")
scatter_plot(trainingData1,"Frequency")
#---------------------------------------------------------
```

```{r tabela_kondygnacji_1_najl}
results <- discretize(trainingData1, breaks = 3, method = "Frequency")
plot(iris$Species~results, col=1:3)
```

```{r tabela_zgodności_1_najl}
compareMatchedClasses(data$Species, results)$diag
```

#### Dla najgorszej

```{r frequences_najg}

#FREQUENCE_METHOD
#---------------------------------------------------------
hist_plot(trainingData2,"Frequency")
scatter_plot(trainingData2,"Frequency")
#---------------------------------------------------------
```

```{r tabela_kondygnacji_1_najg}
results <- discretize(trainingData2, breaks = 3, method = "Frequency")
plot(iris$Species~results, col=1:3)
```

```{r tabela_zgodności_1_najg}
compareMatchedClasses(data$Species, results)$diag
```

### Równe szerokości

#### Dla najlepszej

```{r width_najl}


#WIDTH_METHOD
#---------------------------------------------------------
hist_plot(trainingData1,"Interval")
scatter_plot(trainingData1,"Interval")
#---------------------------------------------------------

```

```{r tabela_kondygnacji_2_najl}
results <- discretize(trainingData1, breaks = 3, method = "Interval")
plot(iris$Species~results, col=1:3)

```

```{r tabela_zgodności_2_najl}

compareMatchedClasses(data$Species, results)$diag
```

#### Dla najgorszej

```{r width_najg}


#WIDTH_METHOD
#---------------------------------------------------------
hist_plot(trainingData2,"Interval")
scatter_plot(trainingData2,"Interval")
#---------------------------------------------------------

```

```{r tabela_kondygnacji_2_najg}
results <- discretize(trainingData2, breaks = 3, method = "Interval")
plot(iris$Species~results, col=1:3)

```

```{r tabela_zgodności_2_najg}

compareMatchedClasses(data$Species, results)$diag
```

### K-means

#### Dla najlepszej

```{r kMeans_najl}
#WIDTH_METHOD
#---------------------------------------------------------
hist_plot(trainingData1,"Cluster")
scatter_plot(trainingData1,"Cluster")
#---------------------------------------------------------

```

```{r tabela_kondygnacji_3_najl}
results <- discretize(trainingData1, breaks = 3, method = "Cluster")
plot(iris$Species~results, col=1:3)

```

```{r tabela_zgodności_3_najl}

compareMatchedClasses(data$Species, results)$diag
```

#### Dla najgorszej

```{r kMeans_najg}
#WIDTH_METHOD
#---------------------------------------------------------
hist_plot(trainingData2,"Cluster")
scatter_plot(trainingData2,"Cluster")
#---------------------------------------------------------

```

```{r tabela_kondygnacji_3_najg}
results <- discretize(trainingData2, breaks = 3, method = "Cluster")
plot(iris$Species~results, col=1:3)

```

```{r tabela_zgodności_3_najg}

compareMatchedClasses(data$Species, results)$diag[1]
```

### Dyskretyzacja z przedziałami zadanymi przez urzytkownika

#### Dla najlepszej

```{r givenRanges_najl}
#GIVEN_RANGES
#---------------------------------------------------------
x.disc.user <- discretize(trainingData1, method = "fixed", 
      breaks = c(-Inf, 0.5, 1.8, Inf), labels = c("small","medium", "large"))

hist(trainingData1, breaks = 10, main = "Metoda: fixed (user provided breaks)")
breaks.user <- c(-Inf, 0.5, 1.8, Inf)
abline(v = breaks.user, col = "red", lwd=2)


plot(trainingData1, data$y, col=iris$Species, main = "Metoda: fixed (user provided breaks)")
abline(v = breaks.user, col = "red", lwd=3)
legend(x = "topright", legend=levels(iris$Species), col=1:3, pch=21, bg = "azure")
#---------------------------------------------------------

```

```{r tabela_kondygnacji_4_najl}
results <- discretize(trainingData1, breaks = 3, method = "Cluster")
plot(iris$Species~results, col=1:3)

```

```{r tabela_zgodności_4_najl}

compareMatchedClasses(data$Species, results)$diag
```

#### Dla najgorszej

```{r givenRanges_najg}
#GIVEN_RANGES
#---------------------------------------------------------
x.disc.user <- discretize(trainingData2, method = "fixed", 
      breaks = c(-Inf, 5, 6, Inf), labels = c("small","medium", "large"))

hist(trainingData2, breaks = 10, main = "Metoda: fixed (user provided breaks)")
breaks.user <- c(-Inf, 5, 6, Inf)
abline(v = breaks.user, col = "red", lwd=2)


plot(trainingData2, data$y, col=iris$Species, main = "Metoda: fixed (user provided breaks)")
abline(v = breaks.user, col = "red", lwd=3)
legend(x = "topright", legend=levels(iris$Species), col=1:3, pch=21, bg = "azure")
#---------------------------------------------------------

```

```{r tabela_kondygnacji_4_najg}
results <- discretize(trainingData2, breaks = 3, method = "Cluster")
plot(iris$Species~results, col=1:3)

```

```{r tabela_zgodności_4_najg}

compareMatchedClasses(data$Species, results)$diag
```

# ZADANIE 2 (Analizaskładowych głównych (Principal Component Analysis (PCA)))
##  a) Dane: City Quality of Life Dataset (plik uaScoresDataFrame.csv, źródło: Kaggle/Teleport.org)
##  b) Przygotowanie danych
##  c) Wyznaczenie składowych głównych
##  d) Zmienność odpowiadająca poszczególnym składowym
##  e) Wizualizacja danych wielowymiarowych
##  f) Korelacja zmiennych
##  g) Końcowe wnioski

```{r zadanie_2_wstep}

# Wczytanie danych
data <- read.csv("uaScoresDataFrame.csv")

# Podstawowy przegląd danych
str(data)
summary(data)
head(data)



# Usuwamy X i zostawiamy tylko liczby
data_numeric <- data[sapply(data, is.numeric) & names(data) != "X"]


# Opcjonalnie podejrzyj:
colnames(data_numeric)



# Wariancje zmiennych
variances <- apply(data_numeric, 2, var)
print(variances)

#należy zrobić standaryzacje ponieważ różnice pomiędzy wariancjami są zbyt znaczące np. Var(Venture.Capital) = 6.52 a Var

# Wykresy pudełkowe dla wszystkich cech
boxplot(data_numeric, las = 2, cex.axis = 0.7, main = "Rozkład cech ilościowych")


# Standaryzacja cech ilościowych
data_numeric_scaled <- scale(data_numeric)

# Można sprawdzić:
summary(data_numeric_scaled)

```

# ZADANIE 3 (Skalowaniewielowymiarowe (Multidimensional Scaling (MDS)))
##  a) Dane: titanic_train (R-pakiet titanic)
##  b) Przygotowanie danych
##  c) Redukcja wymiaru na bazie MDS
##  d) Wizualizacja danych
